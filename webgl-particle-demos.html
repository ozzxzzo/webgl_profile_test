<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Energy Ribbons - 量子能量丝带</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #28f321;
            font-size: 24px;
            text-shadow: 0 0 20px #28f321;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <div id="info">
        Quantum Energy Ribbons<br>
        量子能量丝带
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // 场景设置
        let scene, camera, renderer, composer;
        let ribbons = [];
        let time = 0;

        // 配置参数
        const config = {
            surfaceCount: 4,     // 曲面数量
            gridWidth: 200,      // 网格宽度点数（增加密度）
            gridHeight: 60,      // 网格高度点数（增加密度）
            surfaceWidth: 100,   // 曲面宽度（拉长）
            surfaceHeight: 15,   // 曲面高度
            colorStart: new THREE.Color(0x28f321), // 亮绿色
            colorEnd: new THREE.Color(0x2196F3),   // 蓝色
        };

        // 初始化场景
        function init() {
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.005);

            // 相机
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 55);
            camera.lookAt(0, 0, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // 后处理
            setupPostProcessing();

            // 创建光流曲面
            createSurfaces();

            // 事件监听
            window.addEventListener('resize', onWindowResize);

            // 隐藏加载提示
            document.getElementById('loading').style.display = 'none';
        }

        // 设置后处理（光晕效果）
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,  // 强度
                0.6,  // 半径
                0.3   // 阈值
            );
            composer.addPass(bloomPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        // 创建自定义粒子材质
        function createParticleMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    colorStart: { value: config.colorStart },
                    colorEnd: { value: config.colorEnd }
                },
                vertexShader: `
                    attribute float alpha;
                    attribute float size;
                    attribute vec3 customColor;

                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = customColor;
                        vAlpha = alpha;

                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        // 创建圆角正方形粒子
                        vec2 center = gl_PointCoord - vec2(0.5);
                        vec2 absCenter = abs(center);

                        // 圆角正方形的距离场
                        float cornerRadius = 0.15;
                        float squareSize = 0.45;

                        // 计算到正方形边缘的距离
                        vec2 d = absCenter - vec2(squareSize - cornerRadius);
                        float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - cornerRadius;

                        if (dist > 0.0) discard;

                        // 边缘渐变，中心亮边缘虚化
                        float strength = 1.0 - smoothstep(-0.1, 0.0, dist);
                        strength = pow(strength, 1.5);

                        // 增强亮度
                        gl_FragColor = vec4(vColor * 1.5, strength * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
        }

        // 创建光流曲面
        function createSurfaces() {
            for (let i = 0; i < config.surfaceCount; i++) {
                const surface = createSurface(i, config.surfaceCount);
                ribbons.push(surface);
                scene.add(surface.points);
            }
        }

        // 创建单个光流曲面（网格状粒子）
        function createSurface(index, total) {
            const gridW = config.gridWidth;
            const gridH = config.gridHeight;
            const particleCount = gridW * gridH;
            const geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const alphas = new Float32Array(particleCount);
            const sizes = new Float32Array(particleCount);
            const offsets = new Float32Array(particleCount);
            const gridCoords = new Float32Array(particleCount * 2); // 存储网格坐标

            // 曲面的垂直位置
            const yOffset = (index - total / 2) * 8;
            // 曲面的深度位置
            const zOffset = (index % 2 === 0 ? 1 : -1) * (3 + index * 2);

            let idx = 0;
            for (let iy = 0; iy < gridH; iy++) {
                for (let ix = 0; ix < gridW; ix++) {
                    // 网格归一化坐标 (0-1)
                    const u = ix / (gridW - 1);
                    const v = iy / (gridH - 1);

                    // 存储网格坐标
                    gridCoords[idx * 2] = u;
                    gridCoords[idx * 2 + 1] = v;

                    // 计算世界坐标
                    const x = (u - 0.5) * config.surfaceWidth;
                    const y = (v - 0.5) * config.surfaceHeight + yOffset;
                    const z = zOffset;

                    positions[idx * 3] = x;
                    positions[idx * 3 + 1] = y;
                    positions[idx * 3 + 2] = z;

                    // 颜色渐变（从左到右）
                    const color = new THREE.Color();
                    color.lerpColors(config.colorStart, config.colorEnd, u);
                    colors[idx * 3] = color.r;
                    colors[idx * 3 + 1] = color.g;
                    colors[idx * 3 + 2] = color.b;

                    // 透明度（边缘淡化）
                    const edgeFadeX = Math.sin(u * Math.PI);
                    const edgeFadeY = Math.sin(v * Math.PI);
                    alphas[idx] = edgeFadeX * edgeFadeY * 0.8 + 0.2;

                    // 粒子大小（更小）
                    sizes[idx] = 0.8 + Math.random() * 0.3;

                    // 动画偏移
                    offsets[idx] = Math.random() * Math.PI * 2;

                    idx++;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = createParticleMaterial();
            const points = new THREE.Points(geometry, material);

            return {
                points,
                geometry,
                offsets,
                gridCoords,
                gridW,
                gridH,
                yOffset,
                zOffset,
                waveAmplitude: 2 + Math.random() * 1.5,    // 波动幅度
                waveFrequency: 1 + Math.random() * 1.5,    // 波动频率
                waveSpeed: 0.2 + Math.random() * 0.3,      // 波动速度
                phaseOffset: index * 1.2
            };
        }

        // 更新光流曲面动画
        function updateRibbons() {
            ribbons.forEach((surface, surfaceIndex) => {
                const positions = surface.geometry.attributes.position.array;
                const colors = surface.geometry.attributes.customColor.array;
                const sizes = surface.geometry.attributes.size.array;
                const alphas = surface.geometry.attributes.alpha.array;

                let idx = 0;
                for (let iy = 0; iy < surface.gridH; iy++) {
                    for (let ix = 0; ix < surface.gridW; ix++) {
                        const u = surface.gridCoords[idx * 2];
                        const v = surface.gridCoords[idx * 2 + 1];

                        // 基础位置
                        const x = (u - 0.5) * config.surfaceWidth;
                        const y = (v - 0.5) * config.surfaceHeight + surface.yOffset;
                        const z = surface.zOffset;

                        // 复杂的数学波动效果
                        const waveOffset = surface.phaseOffset + time * surface.waveSpeed;

                        // 螺旋缠绕效果 - 每条粒子线形成螺旋
                        const spiralFreq = 4;  // 螺旋频率
                        const spiralAmp = 1.5; // 螺旋幅度
                        const spiralY = Math.sin(u * Math.PI * spiralFreq + waveOffset + v * Math.PI * 2) * spiralAmp;
                        const spiralZ = Math.cos(u * Math.PI * spiralFreq + waveOffset + v * Math.PI * 2) * spiralAmp;

                        // 主波动 - 横向传播的正弦波
                        const wave1 = Math.sin(u * Math.PI * 3 + waveOffset) * surface.waveAmplitude * 0.8;

                        // 次波动 - 纵向传播的余弦波
                        const wave2 = Math.cos(v * Math.PI * 4 + waveOffset * 1.5) * surface.waveAmplitude * 0.5;

                        // 径向波动 - 从中心扩散的圆形波
                        const centerX = u - 0.5;
                        const centerY = v - 0.5;
                        const distFromCenter = Math.sqrt(centerX * centerX + centerY * centerY);
                        const radialWave = Math.sin(distFromCenter * Math.PI * 6 + waveOffset * 2) * surface.waveAmplitude * 0.3;

                        // 扭曲效果 - 双频调制产生复杂图案
                        const twistX = Math.sin(u * Math.PI * 12 + time * 2) * Math.cos(v * Math.PI * 6 + time) * 0.6;
                        const twistY = Math.cos(u * Math.PI * 6 + time * 1.5) * Math.sin(v * Math.PI * 12 + time * 2) * 0.6;

                        // DNA双螺旋效果（可选层叠）
                        const dnaPhase = u * Math.PI * 8 + waveOffset * 3;
                        const dnaY = Math.sin(dnaPhase + v * Math.PI) * 0.5;
                        const dnaZ = Math.cos(dnaPhase + v * Math.PI) * 0.5;

                        positions[idx * 3] = x + twistX;
                        positions[idx * 3 + 1] = y + spiralY + wave1 + wave2 + radialWave + dnaY + twistY;
                        positions[idx * 3 + 2] = z + spiralZ + dnaZ;

                        // 动态循环渐变色 - 统一的单向流动
                        // 计算流动偏移：随时间单向循环流动
                        const colorFlowSpeed = 0.15; // 颜色流动速度
                        const flowOffset = (time * colorFlowSpeed) % 1.0;

                        // 计算当前粒子的颜色位置（0-1循环）
                        const colorPos = (u + flowOffset) % 1.0;

                        // 平滑的单向渐变：绿色 -> 蓝色 -> 绿色（循环）
                        // 使用 smoothstep 让过渡更柔和
                        let t;
                        if (colorPos < 0.5) {
                            // 前半段：绿色渐变到蓝色
                            t = colorPos * 2; // 0 -> 1
                        } else {
                            // 后半段：蓝色渐变回绿色
                            t = (1.0 - colorPos) * 2; // 1 -> 0
                        }

                        // 应用平滑过渡
                        t = t * t * (3 - 2 * t); // smoothstep

                        // 在绿色和蓝色之间插值
                        const color = new THREE.Color();
                        color.lerpColors(config.colorStart, config.colorEnd, t);

                        colors[idx * 3] = color.r;
                        colors[idx * 3 + 1] = color.g;
                        colors[idx * 3 + 2] = color.b;

                        // 律动的粒子大小 - 规律性的数学脉冲
                        const pulse1 = Math.sin(time * 2 + u * Math.PI * 6) * 0.2;
                        const pulse2 = Math.cos(time * 1.5 + v * Math.PI * 8) * 0.15;
                        sizes[idx] = (0.8 + Math.random() * 0.15) * (1.0 + pulse1 + pulse2);

                        // 律动的透明度 - 呼吸式闪烁
                        const edgeFadeX = Math.sin(u * Math.PI);
                        const edgeFadeY = Math.sin(v * Math.PI);
                        const alphaPulse1 = Math.sin(time * 1.5 + u * Math.PI * 4) * 0.15;
                        const alphaPulse2 = Math.cos(time * 2 + v * Math.PI * 6) * 0.1;
                        alphas[idx] = edgeFadeX * edgeFadeY * (0.75 + alphaPulse1 + alphaPulse2);

                        idx++;
                    }
                }

                surface.geometry.attributes.position.needsUpdate = true;
                surface.geometry.attributes.customColor.needsUpdate = true;
                surface.geometry.attributes.size.needsUpdate = true;
                surface.geometry.attributes.alpha.needsUpdate = true;

                // 更新材质时间
                surface.points.material.uniforms.time.value = time;
            });
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            time += 0.01;

            // 更新丝带
            updateRibbons();

            // 渲染
            composer.render();
        }

        // 启动
        init();
        animate();
    </script>
</body>
</html>
