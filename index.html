<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Energy Ribbons Enhanced - é‡å­èƒ½é‡ä¸å¸¦Â·ç»ˆæç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            line-height: 1.6;
        }

        #info .title {
            font-size: 18px;
            font-weight: bold;
            color: #28f321;
            text-shadow: 0 0 15px rgba(40, 243, 33, 0.8);
        }

        #info .features {
            margin-top: 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #28f321;
            font-size: 24px;
            text-shadow: 0 0 20px #28f321;
        }

        #controlPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid rgba(40, 243, 33, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            font-size: 13px;
            box-shadow: 0 0 40px rgba(40, 243, 33, 0.2), 0 0 80px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            display: none;
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #controlPanel.visible {
            opacity: 1;
            transform: translateX(0);
        }

        #controlPanel h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #28f321;
            text-shadow: 0 0 15px rgba(40, 243, 33, 0.6);
            text-align: center;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h3 {
            margin: 0 0 12px 0;
            font-size: 15px;
            color: #2196F3;
            font-weight: bold;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            color: rgba(255, 255, 255, 0.85);
            font-size: 12px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #28f321;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(40, 243, 33, 0.6);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #28f321;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(40, 243, 33, 0.6);
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
            vertical-align: middle;
        }

        .control-group .checkbox-label {
            display: inline-block;
            vertical-align: middle;
        }

        .control-group .value-display {
            float: right;
            color: #28f321;
            font-weight: bold;
            font-size: 12px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: rgba(40, 243, 33, 0.15);
            border: 1px solid #28f321;
            border-radius: 6px;
            color: #28f321;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(40, 243, 33, 0.25);
            box-shadow: 0 0 20px rgba(40, 243, 33, 0.4);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 18px;
            width: auto;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(40, 243, 33, 0.4);
            margin: 0;
            transition: right 0.3s ease;
            font-size: 12px;
        }

        #controlPanel::-webkit-scrollbar {
            width: 6px;
        }

        #controlPanel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #controlPanel::-webkit-scrollbar-thumb {
            background: rgba(40, 243, 33, 0.5);
            border-radius: 3px;
        }

        #controlPanel::-webkit-scrollbar-thumb:hover {
            background: rgba(40, 243, 33, 0.7);
        }

        .effect-badge {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: rgba(40, 243, 33, 0.2);
            border: 1px solid rgba(40, 243, 33, 0.4);
            border-radius: 10px;
            font-size: 10px;
            color: #28f321;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Ultimate Effects...</div>
    <div id="info">
        <div class="title">Quantum Energy Ribbons - ç»ˆæç‰ˆ</div>
        <div class="features">
            <span class="effect-badge">Neural Links</span>
            <span class="effect-badge">Lightning</span>
            <span class="effect-badge">Shockwave</span><br>
            <span class="effect-badge">Chromatic</span>
            <span class="effect-badge">Lens Flare</span>
            <span class="effect-badge">Nebula</span>
        </div>
    </div>

    <button class="toggle-btn" onclick="togglePanel()">æ§åˆ¶é¢æ¿</button>

    <div id="controlPanel">
        <h2>ğŸ›ï¸ ç»ˆææ§åˆ¶é¢æ¿</h2>

        <div class="control-section">
            <h3>ğŸ¨ åŸºç¡€å‚æ•° Basic</h3>
            <div class="control-group">
                <label>æ›²é¢æ•°é‡ Surfaces: <span class="value-display" id="surfaceCount-value">1</span></label>
                <input type="range" id="surfaceCount" min="1" max="10" step="1" value="1">
            </div>
            <div class="control-group">
                <label>ç½‘æ ¼å¯†åº¦ Grid Density: <span class="value-display" id="gridDensity-value">1.7</span></label>
                <input type="range" id="gridDensity" min="0.2" max="2" step="0.1" value="1.7">
            </div>
            <div class="control-group">
                <label>ä¸å¸¦å®½åº¦ Ribbon Width: <span class="value-display" id="surfaceWidth-value">200</span></label>
                <input type="range" id="surfaceWidth" min="30" max="200" step="5" value="200">
            </div>
            <div class="control-group">
                <label>ä¸å¸¦é«˜åº¦ Ribbon Height: <span class="value-display" id="surfaceHeight-value">29</span></label>
                <input type="range" id="surfaceHeight" min="5" max="40" step="1" value="29">
            </div>
        </div>

        <div class="control-section">
            <h3>ğŸŒˆ é¢œè‰² Colors</h3>
            <div class="control-group">
                <label>èµ·å§‹é¢œè‰² Start Color</label>
                <input type="color" id="colorStart" value="#28f321">
            </div>
            <div class="control-group">
                <label>ç»“æŸé¢œè‰² End Color</label>
                <input type="color" id="colorEnd" value="#2196f3">
            </div>
            <div class="control-group">
                <label>é¢œè‰²æµåŠ¨é€Ÿåº¦ Color Flow: <span class="value-display" id="colorFlowSpeed-value">0.05</span></label>
                <input type="range" id="colorFlowSpeed" min="0" max="0.5" step="0.01" value="0.05">
            </div>
        </div>

        <div class="control-section">
            <h3>âœ¨ å…‰æ•ˆ Lighting</h3>
            <div class="control-group">
                <label>è¾‰å…‰å¼ºåº¦ Bloom Strength: <span class="value-display" id="bloomStrength-value">1.7</span></label>
                <input type="range" id="bloomStrength" min="0" max="3" step="0.1" value="1.7">
            </div>
            <div class="control-group">
                <label>è¾‰å…‰åŠå¾„ Bloom Radius: <span class="value-display" id="bloomRadius-value">0.00</span></label>
                <input type="range" id="bloomRadius" min="0" max="1" step="0.05" value="0.00">
            </div>
            <div class="control-group">
                <label>è¾‰å…‰é˜ˆå€¼ Bloom Threshold: <span class="value-display" id="bloomThreshold-value">0.55</span></label>
                <input type="range" id="bloomThreshold" min="0" max="1" step="0.05" value="0.55">
            </div>
            <div class="control-group">
                <label>äº®åº¦ Brightness: <span class="value-display" id="brightness-value">1.5</span></label>
                <input type="range" id="brightness" min="0.5" max="3" step="0.1" value="1.5">
            </div>
        </div>

        <div class="control-section">
            <h3>ğŸŒŠ æ³¢åŠ¨æ•ˆæœ Wave Effects</h3>
            <div class="control-group">
                <label>æ³¢åŠ¨å¹…åº¦ Wave Amplitude: <span class="value-display" id="waveAmplitude-value">1.7</span></label>
                <input type="range" id="waveAmplitude" min="0" max="8" step="0.1" value="1.7">
            </div>
            <div class="control-group">
                <label>æ³¢åŠ¨é€Ÿåº¦ Wave Speed: <span class="value-display" id="waveSpeed-value">0.27</span></label>
                <input type="range" id="waveSpeed" min="0" max="1" step="0.01" value="0.27">
            </div>
            <div class="control-group">
                <label>èºæ—‹é¢‘ç‡ Spiral Frequency: <span class="value-display" id="spiralFreq-value">11.5</span></label>
                <input type="range" id="spiralFreq" min="0" max="12" step="0.5" value="11.5">
            </div>
            <div class="control-group">
                <label>èºæ—‹å¹…åº¦ Spiral Amplitude: <span class="value-display" id="spiralAmp-value">1.3</span></label>
                <input type="range" id="spiralAmp" min="0" max="5" step="0.1" value="1.3">
            </div>
            <div class="control-group">
                <label>æ‰­æ›²å¼ºåº¦ Twist Strength: <span class="value-display" id="twistStrength-value">1.9</span></label>
                <input type="range" id="twistStrength" min="0" max="3" step="0.1" value="1.9">
            </div>
            <div class="control-group">
                <label>DNAæ•ˆæœå¼ºåº¦ DNA Effect: <span class="value-display" id="dnaStrength-value">0.5</span></label>
                <input type="range" id="dnaStrength" min="0" max="2" step="0.1" value="0.5">
            </div>
        </div>

        <div class="control-section">
            <h3>âš¡ æ–°å¢ç‰¹æ•ˆ New Effects</h3>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableConnections" checked>
                    <span class="checkbox-label">ç²’å­è¿çº¿ Neural Links</span>
                </label>
            </div>
            <div class="control-group">
                <label>è¿çº¿è·ç¦» Link Distance: <span class="value-display" id="connectionDistance-value">15</span></label>
                <input type="range" id="connectionDistance" min="5" max="30" step="1" value="15">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableLightning" checked>
                    <span class="checkbox-label">ç”µå¼§é—ªç”µ Lightning</span>
                </label>
            </div>
            <div class="control-group">
                <label>é—ªç”µé¢‘ç‡ Lightning Freq: <span class="value-display" id="lightningFrequency-value">0.5</span></label>
                <input type="range" id="lightningFrequency" min="0.1" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableShockwave" checked>
                    <span class="checkbox-label">å†²å‡»æ³¢ Shockwave</span>
                </label>
            </div>
            <div class="control-group">
                <label>å†²å‡»æ³¢é¢‘ç‡ Wave Freq: <span class="value-display" id="shockwaveFreq-value">0.2</span></label>
                <input type="range" id="shockwaveFreq" min="0.05" max="1" step="0.05" value="0.2">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableChromaticAberration" checked>
                    <span class="checkbox-label">è‰²å·®æ•ˆæœ Chromatic</span>
                </label>
            </div>
            <div class="control-group">
                <label>è‰²å·®å¼ºåº¦ CA Strength: <span class="value-display" id="chromaticStrength-value">0.002</span></label>
                <input type="range" id="chromaticStrength" min="0" max="0.01" step="0.0005" value="0.002">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableLensFlare" checked>
                    <span class="checkbox-label">é•œå¤´å…‰æ™• Lens Flare</span>
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableNebula" checked>
                    <span class="checkbox-label">æ˜Ÿäº‘èƒŒæ™¯ Nebula</span>
                </label>
            </div>
            <div class="control-group">
                <label>æ˜Ÿäº‘å¯†åº¦ Nebula Density: <span class="value-display" id="nebulaDensity-value">2000</span></label>
                <input type="range" id="nebulaDensity" min="500" max="5000" step="100" value="2000">
            </div>
        </div>

        <div class="control-section">
            <h3>âœ¨ ç²’å­ Particles</h3>
            <div class="control-group">
                <label>ç²’å­å¤§å° Particle Size: <span class="value-display" id="particleSize-value">0.8</span></label>
                <input type="range" id="particleSize" min="0.2" max="2" step="0.1" value="0.8">
            </div>
            <div class="control-group">
                <label>ç²’å­è„‰åŠ¨ Particle Pulse: <span class="value-display" id="particlePulse-value">0.20</span></label>
                <input type="range" id="particlePulse" min="0" max="1" step="0.05" value="0.20">
            </div>
        </div>

        <div class="control-section">
            <h3>ğŸ“· ç›¸æœºä¸ç¯å¢ƒ Camera</h3>
            <div class="control-group">
                <label>ç›¸æœºè·ç¦» Camera Distance: <span class="value-display" id="cameraZ-value">50</span></label>
                <input type="range" id="cameraZ" min="20" max="150" step="5" value="50">
            </div>
            <div class="control-group">
                <label>è§†é‡è§’åº¦ FOV: <span class="value-display" id="fov-value">60</span></label>
                <input type="range" id="fov" min="30" max="120" step="5" value="60">
            </div>
            <div class="control-group">
                <label>é›¾å¯†åº¦ Fog Density: <span class="value-display" id="fogDensity-value">0.011</span></label>
                <input type="range" id="fogDensity" min="0" max="0.02" step="0.001" value="0.011">
            </div>
            <div class="control-group">
                <label>åŠ¨ç”»é€Ÿåº¦ Animation Speed: <span class="value-display" id="timeSpeed-value">0.8</span></label>
                <input type="range" id="timeSpeed" min="0" max="3" step="0.1" value="0.8">
            </div>
        </div>

        <button onclick="resetToDefault()">ğŸ”„ é‡ç½®é»˜è®¤å€¼ Reset</button>
        <button onclick="randomize()">ğŸ² éšæœºåŒ– Randomize</button>
        <button onclick="toggleAllEffects()">âš¡ å…¨æ•ˆæœå¼€å…³ Toggle All</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

        // åœºæ™¯è®¾ç½®
        let scene, camera, renderer, composer, bloomPass, chromaticPass;
        let ribbons = [];
        let connectionLines = null;
        let lightningBolts = [];
        let shockwaves = [];
        let nebulaParticles = null;
        let lensflares = [];
        let time = 0;

        // é…ç½®å‚æ•° - å®Œæ•´çš„å¯é…ç½®å‚æ•°é›†
        const config = {
            // åŸºç¡€å‚æ•°
            surfaceCount: 1,
            gridWidth: 200,
            gridHeight: 60,
            surfaceWidth: 200,
            surfaceHeight: 29,
            gridDensity: 1.7,

            // é¢œè‰²å‚æ•°
            colorStart: new THREE.Color(0x28f321),
            colorEnd: new THREE.Color(0x2196F3),
            colorFlowSpeed: 0.05,

            // å…‰æ•ˆå‚æ•°
            bloomStrength: 1.7,
            bloomRadius: 0.00,
            bloomThreshold: 0.55,
            brightness: 1.5,

            // æ³¢åŠ¨æ•ˆæœå‚æ•°
            waveAmplitude: 1.7,
            waveSpeed: 0.27,
            spiralFreq: 11.5,
            spiralAmp: 1.3,
            twistStrength: 1.9,
            dnaStrength: 0.5,

            // ç²’å­å‚æ•°
            particleSize: 0.8,
            particlePulse: 0.20,

            // ç›¸æœºä¸ç¯å¢ƒ
            cameraZ: 50,
            fov: 60,
            fogDensity: 0.011,
            timeSpeed: 0.8,

            // æ–°å¢ç‰¹æ•ˆå‚æ•°
            enableConnections: true,
            connectionDistance: 15,
            enableLightning: true,
            lightningFrequency: 0.5,
            enableShockwave: true,
            shockwaveFreq: 0.2,
            enableChromaticAberration: true,
            chromaticStrength: 0.002,
            enableLensFlare: true,
            enableNebula: true,
            nebulaDensity: 2000
        };

        // é»˜è®¤é…ç½®å¤‡ä»½
        const defaultConfig = JSON.parse(JSON.stringify({...config, colorStart: 0x28f321, colorEnd: 0x2196F3}));

        // è‰²å·®æ•ˆæœ Shader
        const ChromaticAberrationShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'amount': { value: 0.002 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                varying vec2 vUv;

                void main() {
                    vec2 offset = amount * vec2(cos(vUv.y * 10.0), sin(vUv.x * 10.0));

                    vec4 cr = texture2D(tDiffuse, vUv + offset);
                    vec4 cg = texture2D(tDiffuse, vUv);
                    vec4 cb = texture2D(tDiffuse, vUv - offset);

                    gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
                }
            `
        };

        // æ§åˆ¶é¢æ¿åˆ‡æ¢
        window.togglePanel = function() {
            const panel = document.getElementById('controlPanel');
            const toggleBtn = document.querySelector('.toggle-btn');
            const isVisible = panel.classList.contains('visible');

            if (!isVisible) {
                panel.style.display = 'block';
                setTimeout(() => {
                    panel.classList.add('visible');
                }, 10);
                toggleBtn.style.right = '380px';
                toggleBtn.textContent = 'éšè—é¢æ¿';
            } else {
                panel.classList.remove('visible');
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 300);
                toggleBtn.style.right = '20px';
                toggleBtn.textContent = 'æ§åˆ¶é¢æ¿';
            }
        }

        // é‡ç½®ä¸ºé»˜è®¤å€¼
        window.resetToDefault = function() {
            config.colorStart = new THREE.Color(defaultConfig.colorStart);
            config.colorEnd = new THREE.Color(defaultConfig.colorEnd);
            Object.assign(config, {...defaultConfig, colorStart: config.colorStart, colorEnd: config.colorEnd});
            updateUIFromConfig();
            needsRebuild = true;
        }

        // éšæœºåŒ–å‚æ•°
        window.randomize = function() {
            config.surfaceCount = Math.floor(Math.random() * 8) + 2;
            config.gridDensity = Math.random() * 1.5 + 0.5;
            config.surfaceWidth = Math.random() * 120 + 50;
            config.surfaceHeight = Math.random() * 30 + 10;
            config.colorFlowSpeed = Math.random() * 0.4;
            config.bloomStrength = Math.random() * 2 + 0.5;
            config.bloomRadius = Math.random();
            config.bloomThreshold = Math.random() * 0.5;
            config.brightness = Math.random() * 2 + 0.5;
            config.waveAmplitude = Math.random() * 6 + 1;
            config.waveSpeed = Math.random() * 0.8 + 0.1;
            config.spiralFreq = Math.random() * 10 + 1;
            config.spiralAmp = Math.random() * 4 + 0.5;
            config.twistStrength = Math.random() * 2;
            config.dnaStrength = Math.random() * 1.5;
            config.particleSize = Math.random() * 1.5 + 0.3;
            config.particlePulse = Math.random() * 0.8;
            config.cameraZ = Math.random() * 80 + 40;
            config.fov = Math.random() * 60 + 40;
            config.fogDensity = Math.random() * 0.015;
            config.timeSpeed = Math.random() * 2 + 0.2;

            const randomColor1 = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            const randomColor2 = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            config.colorStart = new THREE.Color(randomColor1);
            config.colorEnd = new THREE.Color(randomColor2);

            config.connectionDistance = Math.random() * 20 + 10;
            config.lightningFrequency = Math.random() * 1.5 + 0.2;
            config.shockwaveFreq = Math.random() * 0.8 + 0.1;
            config.chromaticStrength = Math.random() * 0.008;
            config.nebulaDensity = Math.random() * 4000 + 1000;

            updateUIFromConfig();
            needsRebuild = true;
        }

        // å…¨æ•ˆæœå¼€å…³
        window.toggleAllEffects = function() {
            const allEnabled = config.enableConnections && config.enableLightning &&
                             config.enableShockwave && config.enableChromaticAberration &&
                             config.enableLensFlare && config.enableNebula;

            config.enableConnections = !allEnabled;
            config.enableLightning = !allEnabled;
            config.enableShockwave = !allEnabled;
            config.enableChromaticAberration = !allEnabled;
            config.enableLensFlare = !allEnabled;
            config.enableNebula = !allEnabled;

            updateUIFromConfig();
        }

        // ä»é…ç½®æ›´æ–°UI
        function updateUIFromConfig() {
            document.getElementById('surfaceCount').value = config.surfaceCount;
            document.getElementById('surfaceCount-value').textContent = config.surfaceCount;

            document.getElementById('gridDensity').value = config.gridDensity;
            document.getElementById('gridDensity-value').textContent = config.gridDensity.toFixed(1);

            document.getElementById('surfaceWidth').value = config.surfaceWidth;
            document.getElementById('surfaceWidth-value').textContent = config.surfaceWidth;

            document.getElementById('surfaceHeight').value = config.surfaceHeight;
            document.getElementById('surfaceHeight-value').textContent = config.surfaceHeight;

            document.getElementById('colorStart').value = '#' + config.colorStart.getHexString();
            document.getElementById('colorEnd').value = '#' + config.colorEnd.getHexString();

            document.getElementById('colorFlowSpeed').value = config.colorFlowSpeed;
            document.getElementById('colorFlowSpeed-value').textContent = config.colorFlowSpeed.toFixed(2);

            document.getElementById('bloomStrength').value = config.bloomStrength;
            document.getElementById('bloomStrength-value').textContent = config.bloomStrength.toFixed(1);

            document.getElementById('bloomRadius').value = config.bloomRadius;
            document.getElementById('bloomRadius-value').textContent = config.bloomRadius.toFixed(2);

            document.getElementById('bloomThreshold').value = config.bloomThreshold;
            document.getElementById('bloomThreshold-value').textContent = config.bloomThreshold.toFixed(2);

            document.getElementById('brightness').value = config.brightness;
            document.getElementById('brightness-value').textContent = config.brightness.toFixed(1);

            document.getElementById('waveAmplitude').value = config.waveAmplitude;
            document.getElementById('waveAmplitude-value').textContent = config.waveAmplitude.toFixed(1);

            document.getElementById('waveSpeed').value = config.waveSpeed;
            document.getElementById('waveSpeed-value').textContent = config.waveSpeed.toFixed(2);

            document.getElementById('spiralFreq').value = config.spiralFreq;
            document.getElementById('spiralFreq-value').textContent = config.spiralFreq.toFixed(1);

            document.getElementById('spiralAmp').value = config.spiralAmp;
            document.getElementById('spiralAmp-value').textContent = config.spiralAmp.toFixed(1);

            document.getElementById('twistStrength').value = config.twistStrength;
            document.getElementById('twistStrength-value').textContent = config.twistStrength.toFixed(1);

            document.getElementById('dnaStrength').value = config.dnaStrength;
            document.getElementById('dnaStrength-value').textContent = config.dnaStrength.toFixed(1);

            document.getElementById('particleSize').value = config.particleSize;
            document.getElementById('particleSize-value').textContent = config.particleSize.toFixed(1);

            document.getElementById('particlePulse').value = config.particlePulse;
            document.getElementById('particlePulse-value').textContent = config.particlePulse.toFixed(2);

            document.getElementById('cameraZ').value = config.cameraZ;
            document.getElementById('cameraZ-value').textContent = config.cameraZ;

            document.getElementById('fov').value = config.fov;
            document.getElementById('fov-value').textContent = config.fov;

            document.getElementById('fogDensity').value = config.fogDensity;
            document.getElementById('fogDensity-value').textContent = config.fogDensity.toFixed(3);

            document.getElementById('timeSpeed').value = config.timeSpeed;
            document.getElementById('timeSpeed-value').textContent = config.timeSpeed.toFixed(1);

            // æ–°å¢ç‰¹æ•ˆ
            document.getElementById('enableConnections').checked = config.enableConnections;
            document.getElementById('connectionDistance').value = config.connectionDistance;
            document.getElementById('connectionDistance-value').textContent = config.connectionDistance;

            document.getElementById('enableLightning').checked = config.enableLightning;
            document.getElementById('lightningFrequency').value = config.lightningFrequency;
            document.getElementById('lightningFrequency-value').textContent = config.lightningFrequency.toFixed(1);

            document.getElementById('enableShockwave').checked = config.enableShockwave;
            document.getElementById('shockwaveFreq').value = config.shockwaveFreq;
            document.getElementById('shockwaveFreq-value').textContent = config.shockwaveFreq.toFixed(2);

            document.getElementById('enableChromaticAberration').checked = config.enableChromaticAberration;
            document.getElementById('chromaticStrength').value = config.chromaticStrength;
            document.getElementById('chromaticStrength-value').textContent = config.chromaticStrength.toFixed(4);

            document.getElementById('enableLensFlare').checked = config.enableLensFlare;

            document.getElementById('enableNebula').checked = config.enableNebula;
            document.getElementById('nebulaDensity').value = config.nebulaDensity;
            document.getElementById('nebulaDensity-value').textContent = config.nebulaDensity;
        }

        // éœ€è¦é‡å»ºæ ‡å¿—
        let needsRebuild = false;

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0f, config.fogDensity);

            camera = new THREE.PerspectiveCamera(
                config.fov,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, config.cameraZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = config.brightness;
            document.body.appendChild(renderer.domElement);

            setupPostProcessing();
            createSurfaces();
            createNebula();
            createConnectionLines();
            createLensFlares();
            setupControls();
            updateUIFromConfig();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('loading').style.display = 'none';
        }

        // è®¾ç½®åå¤„ç†
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                config.bloomStrength,
                config.bloomRadius,
                config.bloomThreshold
            );
            composer.addPass(bloomPass);

            chromaticPass = new ShaderPass(ChromaticAberrationShader);
            chromaticPass.uniforms['amount'].value = config.chromaticStrength;
            composer.addPass(chromaticPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        // åˆ›å»ºæ˜Ÿäº‘èƒŒæ™¯
        function createNebula() {
            const nebulaGeometry = new THREE.BufferGeometry();
            const nebulaCount = config.nebulaDensity;
            const positions = new Float32Array(nebulaCount * 3);
            const colors = new Float32Array(nebulaCount * 3);
            const sizes = new Float32Array(nebulaCount);

            for (let i = 0; i < nebulaCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400 - 100;

                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.3 + 0.5, 0.5, 0.2);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                sizes[i] = Math.random() * 2 + 0.5;
            }

            nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const nebulaMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            nebulaParticles = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebulaParticles);
        }

        // åˆ›å»ºé•œå¤´å…‰æ™•
        function createLensFlares() {
            const textureLoader = new THREE.TextureLoader();

            // åˆ›å»ºå¤šä¸ªå…‰æ™•å…‰æº
            const flarePositions = [
                new THREE.Vector3(30, 10, -20),
                new THREE.Vector3(-30, -10, -20),
                new THREE.Vector3(0, 20, -30)
            ];

            flarePositions.forEach((pos, index) => {
                const light = new THREE.PointLight(0xffffff, 1.5, 100);
                light.position.copy(pos);

                // ç®€åŒ–çš„å…‰æ™•æ•ˆæœ - ä½¿ç”¨è‡ªå®šä¹‰ç²’å­ä»£æ›¿
                const flareGeometry = new THREE.SphereGeometry(2, 16, 16);
                const flareMaterial = new THREE.MeshBasicMaterial({
                    color: index === 0 ? 0x28f321 : (index === 1 ? 0x2196F3 : 0xff00ff),
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const flareMesh = new THREE.Mesh(flareGeometry, flareMaterial);
                flareMesh.position.copy(pos);

                lensflares.push({ light, mesh: flareMesh, basePos: pos.clone() });
                scene.add(light);
                scene.add(flareMesh);
            });
        }

        // åˆ›å»ºç²’å­è¿çº¿
        function createConnectionLines() {
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x28f321,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });

            const lineGeometry = new THREE.BufferGeometry();
            connectionLines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(connectionLines);
        }

        // æ›´æ–°ç²’å­è¿çº¿
        function updateConnectionLines() {
            if (!config.enableConnections || ribbons.length === 0) {
                connectionLines.visible = false;
                return;
            }
            connectionLines.visible = true;

            const positions = [];
            const maxConnections = 500; // é™åˆ¶è¿çº¿æ•°é‡ä»¥ä¼˜åŒ–æ€§èƒ½
            let connectionCount = 0;

            ribbons.forEach((surface) => {
                const surfacePositions = surface.geometry.attributes.position.array;
                const particleCount = surfacePositions.length / 3;

                // é‡‡æ ·éƒ¨åˆ†ç²’å­ä»¥ä¼˜åŒ–æ€§èƒ½
                const sampleRate = Math.max(1, Math.floor(particleCount / 200));

                for (let i = 0; i < particleCount && connectionCount < maxConnections; i += sampleRate) {
                    const x1 = surfacePositions[i * 3];
                    const y1 = surfacePositions[i * 3 + 1];
                    const z1 = surfacePositions[i * 3 + 2];

                    for (let j = i + sampleRate; j < particleCount && connectionCount < maxConnections; j += sampleRate) {
                        const x2 = surfacePositions[j * 3];
                        const y2 = surfacePositions[j * 3 + 1];
                        const z2 = surfacePositions[j * 3 + 2];

                        const dx = x2 - x1;
                        const dy = y2 - y1;
                        const dz = z2 - z1;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (distance < config.connectionDistance) {
                            positions.push(x1, y1, z1, x2, y2, z2);
                            connectionCount++;
                        }
                    }
                }
            });

            connectionLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            connectionLines.geometry.attributes.position.needsUpdate = true;
        }

        // åˆ›å»ºé—ªç”µæ•ˆæœ
        function createLightning() {
            if (!config.enableLightning || ribbons.length < 2) return;

            if (Math.random() < config.lightningFrequency * 0.01) {
                const surface1 = ribbons[Math.floor(Math.random() * ribbons.length)];
                const surface2 = ribbons[Math.floor(Math.random() * ribbons.length)];

                if (surface1 === surface2) return;

                const pos1 = surface1.geometry.attributes.position.array;
                const pos2 = surface2.geometry.attributes.position.array;

                const idx1 = Math.floor(Math.random() * (pos1.length / 3)) * 3;
                const idx2 = Math.floor(Math.random() * (pos2.length / 3)) * 3;

                const start = new THREE.Vector3(pos1[idx1], pos1[idx1 + 1], pos1[idx1 + 2]);
                const end = new THREE.Vector3(pos2[idx2], pos2[idx2 + 1], pos2[idx2 + 2]);

                const lightningPoints = [];
                const segments = 10;

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const point = new THREE.Vector3().lerpVectors(start, end, t);

                    if (i > 0 && i < segments) {
                        point.x += (Math.random() - 0.5) * 3;
                        point.y += (Math.random() - 0.5) * 3;
                        point.z += (Math.random() - 0.5) * 3;
                    }

                    lightningPoints.push(point);
                }

                const lightningGeometry = new THREE.BufferGeometry().setFromPoints(lightningPoints);
                const lightningMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    linewidth: 2
                });

                const lightning = new THREE.Line(lightningGeometry, lightningMaterial);
                lightning.userData.lifespan = 0.3; // æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
                lightning.userData.age = 0;

                lightningBolts.push(lightning);
                scene.add(lightning);
            }

            // æ›´æ–°å’Œç§»é™¤æ—§é—ªç”µ
            for (let i = lightningBolts.length - 1; i >= 0; i--) {
                lightningBolts[i].userData.age += 0.016;
                lightningBolts[i].material.opacity = 1 - (lightningBolts[i].userData.age / lightningBolts[i].userData.lifespan);

                if (lightningBolts[i].userData.age >= lightningBolts[i].userData.lifespan) {
                    scene.remove(lightningBolts[i]);
                    lightningBolts[i].geometry.dispose();
                    lightningBolts[i].material.dispose();
                    lightningBolts.splice(i, 1);
                }
            }
        }

        // åˆ›å»ºå†²å‡»æ³¢
        function createShockwave() {
            if (!config.enableShockwave) return;

            if (Math.random() < config.shockwaveFreq * 0.01) {
                const shockwaveGeometry = new THREE.RingGeometry(0.1, 1, 32);
                const shockwaveMaterial = new THREE.MeshBasicMaterial({
                    color: config.colorStart,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });

                const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
                shockwave.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 20
                );
                shockwave.rotation.x = Math.random() * Math.PI;
                shockwave.rotation.y = Math.random() * Math.PI;

                shockwave.userData.lifespan = 2;
                shockwave.userData.age = 0;
                shockwave.userData.maxScale = 20 + Math.random() * 20;

                shockwaves.push(shockwave);
                scene.add(shockwave);
            }

            // æ›´æ–°å†²å‡»æ³¢
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const wave = shockwaves[i];
                wave.userData.age += 0.016;
                const progress = wave.userData.age / wave.userData.lifespan;

                const scale = 1 + progress * wave.userData.maxScale;
                wave.scale.set(scale, scale, scale);
                wave.material.opacity = 0.8 * (1 - progress);

                if (progress >= 1) {
                    scene.remove(wave);
                    wave.geometry.dispose();
                    wave.material.dispose();
                    shockwaves.splice(i, 1);
                }
            }
        }

        // åˆ›å»ºç²’å­æè´¨
        function createParticleMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    colorStart: { value: config.colorStart },
                    colorEnd: { value: config.colorEnd }
                },
                vertexShader: `
                    attribute float alpha;
                    attribute float size;
                    attribute vec3 customColor;

                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vColor = customColor;
                        vAlpha = alpha;

                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;

                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        vec2 absCenter = abs(center);

                        float cornerRadius = 0.15;
                        float squareSize = 0.45;

                        vec2 d = absCenter - vec2(squareSize - cornerRadius);
                        float dist = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - cornerRadius;

                        if (dist > 0.0) discard;

                        float strength = 1.0 - smoothstep(-0.1, 0.0, dist);
                        strength = pow(strength, 1.5);

                        gl_FragColor = vec4(vColor * 1.8, strength * vAlpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
        }

        // åˆ›å»ºå…‰æµæ›²é¢
        function createSurfaces() {
            for (let i = 0; i < config.surfaceCount; i++) {
                const surface = createSurface(i, config.surfaceCount);
                ribbons.push(surface);
                scene.add(surface.points);
            }
        }

        // åˆ›å»ºå•ä¸ªå…‰æµæ›²é¢
        function createSurface(index, total) {
            const gridW = Math.floor(config.gridWidth * config.gridDensity);
            const gridH = Math.floor(config.gridHeight * config.gridDensity);
            const particleCount = gridW * gridH;
            const geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const alphas = new Float32Array(particleCount);
            const sizes = new Float32Array(particleCount);
            const offsets = new Float32Array(particleCount);
            const gridCoords = new Float32Array(particleCount * 2);

            const yOffset = (index - total / 2) * 8;
            const zOffset = (index % 2 === 0 ? 1 : -1) * (3 + index * 2);

            let idx = 0;
            for (let iy = 0; iy < gridH; iy++) {
                for (let ix = 0; ix < gridW; ix++) {
                    const u = ix / (gridW - 1);
                    const v = iy / (gridH - 1);

                    gridCoords[idx * 2] = u;
                    gridCoords[idx * 2 + 1] = v;

                    const x = (u - 0.5) * config.surfaceWidth;
                    const y = (v - 0.5) * config.surfaceHeight + yOffset;
                    const z = zOffset;

                    positions[idx * 3] = x;
                    positions[idx * 3 + 1] = y;
                    positions[idx * 3 + 2] = z;

                    const color = new THREE.Color();
                    color.lerpColors(config.colorStart, config.colorEnd, u);
                    colors[idx * 3] = color.r;
                    colors[idx * 3 + 1] = color.g;
                    colors[idx * 3 + 2] = color.b;

                    const edgeFadeX = Math.sin(u * Math.PI);
                    const edgeFadeY = Math.sin(v * Math.PI);
                    alphas[idx] = edgeFadeX * edgeFadeY * 0.8 + 0.2;

                    sizes[idx] = config.particleSize + Math.random() * 0.3;
                    offsets[idx] = Math.random() * Math.PI * 2;

                    idx++;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = createParticleMaterial();
            const points = new THREE.Points(geometry, material);

            return {
                points,
                geometry,
                offsets,
                gridCoords,
                gridW,
                gridH,
                yOffset,
                zOffset,
                phaseOffset: index * 1.2
            };
        }

        // æ›´æ–°å…‰æµæ›²é¢åŠ¨ç”»
        function updateRibbons() {
            ribbons.forEach((surface, surfaceIndex) => {
                const positions = surface.geometry.attributes.position.array;
                const colors = surface.geometry.attributes.customColor.array;
                const sizes = surface.geometry.attributes.size.array;
                const alphas = surface.geometry.attributes.alpha.array;

                let idx = 0;
                for (let iy = 0; iy < surface.gridH; iy++) {
                    for (let ix = 0; ix < surface.gridW; ix++) {
                        const u = surface.gridCoords[idx * 2];
                        const v = surface.gridCoords[idx * 2 + 1];

                        const x = (u - 0.5) * config.surfaceWidth;
                        const y = (v - 0.5) * config.surfaceHeight + surface.yOffset;
                        const z = surface.zOffset;

                        const waveOffset = surface.phaseOffset + time * config.waveSpeed;

                        const spiralY = Math.sin(u * Math.PI * config.spiralFreq + waveOffset + v * Math.PI * 2) * config.spiralAmp;
                        const spiralZ = Math.cos(u * Math.PI * config.spiralFreq + waveOffset + v * Math.PI * 2) * config.spiralAmp;

                        const wave1 = Math.sin(u * Math.PI * 3 + waveOffset) * config.waveAmplitude * 0.8;
                        const wave2 = Math.cos(v * Math.PI * 4 + waveOffset * 1.5) * config.waveAmplitude * 0.5;

                        const centerX = u - 0.5;
                        const centerY = v - 0.5;
                        const distFromCenter = Math.sqrt(centerX * centerX + centerY * centerY);
                        const radialWave = Math.sin(distFromCenter * Math.PI * 6 + waveOffset * 2) * config.waveAmplitude * 0.3;

                        const twistX = Math.sin(u * Math.PI * 12 + time * 2) * Math.cos(v * Math.PI * 6 + time) * config.twistStrength;
                        const twistY = Math.cos(u * Math.PI * 6 + time * 1.5) * Math.sin(v * Math.PI * 12 + time * 2) * config.twistStrength;

                        const dnaPhase = u * Math.PI * 8 + waveOffset * 3;
                        const dnaY = Math.sin(dnaPhase + v * Math.PI) * config.dnaStrength;
                        const dnaZ = Math.cos(dnaPhase + v * Math.PI) * config.dnaStrength;

                        positions[idx * 3] = x + twistX;
                        positions[idx * 3 + 1] = y + spiralY + wave1 + wave2 + radialWave + dnaY + twistY;
                        positions[idx * 3 + 2] = z + spiralZ + dnaZ;

                        const flowOffset = (time * config.colorFlowSpeed) % 1.0;
                        const colorPos = (u + flowOffset) % 1.0;

                        let t;
                        if (colorPos < 0.5) {
                            t = colorPos * 2;
                        } else {
                            t = (1.0 - colorPos) * 2;
                        }

                        t = t * t * (3 - 2 * t);

                        const color = new THREE.Color();
                        color.lerpColors(config.colorStart, config.colorEnd, t);

                        colors[idx * 3] = color.r;
                        colors[idx * 3 + 1] = color.g;
                        colors[idx * 3 + 2] = color.b;

                        const pulse1 = Math.sin(time * 2 + u * Math.PI * 6) * config.particlePulse;
                        const pulse2 = Math.cos(time * 1.5 + v * Math.PI * 8) * config.particlePulse * 0.75;
                        sizes[idx] = (config.particleSize + Math.random() * 0.15) * (1.0 + pulse1 + pulse2);

                        const edgeFadeX = Math.sin(u * Math.PI);
                        const edgeFadeY = Math.sin(v * Math.PI);
                        const alphaPulse1 = Math.sin(time * 1.5 + u * Math.PI * 4) * config.particlePulse * 0.75;
                        const alphaPulse2 = Math.cos(time * 2 + v * Math.PI * 6) * config.particlePulse * 0.5;
                        alphas[idx] = edgeFadeX * edgeFadeY * (0.75 + alphaPulse1 + alphaPulse2);

                        idx++;
                    }
                }

                surface.geometry.attributes.position.needsUpdate = true;
                surface.geometry.attributes.customColor.needsUpdate = true;
                surface.geometry.attributes.size.needsUpdate = true;
                surface.geometry.attributes.alpha.needsUpdate = true;

                surface.points.material.uniforms.time.value = time;
            });
        }

        // æ›´æ–°é•œå¤´å…‰æ™•
        function updateLensFlares() {
            if (!config.enableLensFlare) {
                lensflares.forEach(flare => {
                    flare.light.visible = false;
                    flare.mesh.visible = false;
                });
                return;
            }

            lensflares.forEach((flare, index) => {
                flare.light.visible = true;
                flare.mesh.visible = true;

                const offset = index * Math.PI * 2 / lensflares.length;
                flare.light.position.x = flare.basePos.x + Math.sin(time + offset) * 10;
                flare.light.position.y = flare.basePos.y + Math.cos(time * 0.7 + offset) * 5;
                flare.mesh.position.copy(flare.light.position);

                flare.mesh.material.opacity = 0.4 + Math.sin(time * 2 + offset) * 0.2;
            });
        }

        // æ›´æ–°æ˜Ÿäº‘
        function updateNebula() {
            if (!config.enableNebula) {
                nebulaParticles.visible = false;
                return;
            }
            nebulaParticles.visible = true;
            nebulaParticles.rotation.y += 0.0002;
            nebulaParticles.rotation.x += 0.0001;
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            time += 0.01 * config.timeSpeed;

            if (needsRebuild) {
                rebuildScene();
                needsRebuild = false;
            }

            updateRealTimeParameters();
            updateRibbons();
            updateConnectionLines();
            createLightning();
            createShockwave();
            updateLensFlares();
            updateNebula();

            composer.render();
        }

        // æ›´æ–°å®æ—¶å‚æ•°
        function updateRealTimeParameters() {
            camera.position.z = config.cameraZ;
            camera.fov = config.fov;
            camera.updateProjectionMatrix();

            if (scene.fog) {
                scene.fog.density = config.fogDensity;
            }

            if (bloomPass) {
                bloomPass.strength = config.bloomStrength;
                bloomPass.radius = config.bloomRadius;
                bloomPass.threshold = config.bloomThreshold;
            }

            if (chromaticPass) {
                chromaticPass.uniforms['amount'].value = config.enableChromaticAberration ? config.chromaticStrength : 0;
            }

            renderer.toneMappingExposure = config.brightness;

            ribbons.forEach(surface => {
                if (surface.points && surface.points.material && surface.points.material.uniforms) {
                    surface.points.material.uniforms.colorStart.value = config.colorStart;
                    surface.points.material.uniforms.colorEnd.value = config.colorEnd;
                }
            });
        }

        // é‡å»ºåœºæ™¯
        function rebuildScene() {
            ribbons.forEach(surface => {
                scene.remove(surface.points);
                surface.geometry.dispose();
                surface.points.material.dispose();
            });
            ribbons = [];

            if (nebulaParticles) {
                scene.remove(nebulaParticles);
                nebulaParticles.geometry.dispose();
                nebulaParticles.material.dispose();
            }

            createSurfaces();
            createNebula();
        }

        // è®¾ç½®æ§åˆ¶é¢æ¿äº‹ä»¶ç›‘å¬å™¨
        function setupControls() {
            setupSlider('surfaceCount', (val) => {
                config.surfaceCount = parseInt(val);
                needsRebuild = true;
            });

            setupSlider('gridDensity', (val) => {
                config.gridDensity = parseFloat(val);
                needsRebuild = true;
            });

            setupSlider('surfaceWidth', (val) => {
                config.surfaceWidth = parseFloat(val);
            });

            setupSlider('surfaceHeight', (val) => {
                config.surfaceHeight = parseFloat(val);
            });

            setupColorPicker('colorStart', (val) => {
                config.colorStart = new THREE.Color(val);
            });

            setupColorPicker('colorEnd', (val) => {
                config.colorEnd = new THREE.Color(val);
            });

            setupSlider('colorFlowSpeed', (val) => {
                config.colorFlowSpeed = parseFloat(val);
            });

            setupSlider('bloomStrength', (val) => {
                config.bloomStrength = parseFloat(val);
            });

            setupSlider('bloomRadius', (val) => {
                config.bloomRadius = parseFloat(val);
            });

            setupSlider('bloomThreshold', (val) => {
                config.bloomThreshold = parseFloat(val);
            });

            setupSlider('brightness', (val) => {
                config.brightness = parseFloat(val);
            });

            setupSlider('waveAmplitude', (val) => {
                config.waveAmplitude = parseFloat(val);
            });

            setupSlider('waveSpeed', (val) => {
                config.waveSpeed = parseFloat(val);
            });

            setupSlider('spiralFreq', (val) => {
                config.spiralFreq = parseFloat(val);
            });

            setupSlider('spiralAmp', (val) => {
                config.spiralAmp = parseFloat(val);
            });

            setupSlider('twistStrength', (val) => {
                config.twistStrength = parseFloat(val);
            });

            setupSlider('dnaStrength', (val) => {
                config.dnaStrength = parseFloat(val);
            });

            setupSlider('particleSize', (val) => {
                config.particleSize = parseFloat(val);
            });

            setupSlider('particlePulse', (val) => {
                config.particlePulse = parseFloat(val);
            });

            setupSlider('cameraZ', (val) => {
                config.cameraZ = parseFloat(val);
            });

            setupSlider('fov', (val) => {
                config.fov = parseFloat(val);
            });

            setupSlider('fogDensity', (val) => {
                config.fogDensity = parseFloat(val);
            });

            setupSlider('timeSpeed', (val) => {
                config.timeSpeed = parseFloat(val);
            });

            // æ–°å¢ç‰¹æ•ˆæ§åˆ¶
            setupCheckbox('enableConnections', (val) => {
                config.enableConnections = val;
            });

            setupSlider('connectionDistance', (val) => {
                config.connectionDistance = parseFloat(val);
            });

            setupCheckbox('enableLightning', (val) => {
                config.enableLightning = val;
            });

            setupSlider('lightningFrequency', (val) => {
                config.lightningFrequency = parseFloat(val);
            });

            setupCheckbox('enableShockwave', (val) => {
                config.enableShockwave = val;
            });

            setupSlider('shockwaveFreq', (val) => {
                config.shockwaveFreq = parseFloat(val);
            });

            setupCheckbox('enableChromaticAberration', (val) => {
                config.enableChromaticAberration = val;
            });

            setupSlider('chromaticStrength', (val) => {
                config.chromaticStrength = parseFloat(val);
            });

            setupCheckbox('enableLensFlare', (val) => {
                config.enableLensFlare = val;
            });

            setupCheckbox('enableNebula', (val) => {
                config.enableNebula = val;
            });

            setupSlider('nebulaDensity', (val) => {
                config.nebulaDensity = parseFloat(val);
                needsRebuild = true;
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¾ç½®æ»‘å—
        function setupSlider(id, callback) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + '-value');

            slider.addEventListener('input', (e) => {
                const val = e.target.value;
                callback(val);

                const step = parseFloat(slider.step);
                if (step >= 1) {
                    valueDisplay.textContent = parseInt(val);
                } else if (step >= 0.1) {
                    valueDisplay.textContent = parseFloat(val).toFixed(1);
                } else if (step >= 0.01) {
                    valueDisplay.textContent = parseFloat(val).toFixed(2);
                } else if (step >= 0.001) {
                    valueDisplay.textContent = parseFloat(val).toFixed(3);
                } else {
                    valueDisplay.textContent = parseFloat(val).toFixed(4);
                }
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¾ç½®é¢œè‰²é€‰æ‹©å™¨
        function setupColorPicker(id, callback) {
            const picker = document.getElementById(id);
            picker.addEventListener('input', (e) => {
                callback(e.target.value);
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¾ç½®å¤é€‰æ¡†
        function setupCheckbox(id, callback) {
            const checkbox = document.getElementById(id);
            checkbox.addEventListener('change', (e) => {
                callback(e.target.checked);
            });
        }

        // å¯åŠ¨
        init();
        animate();
    </script>
</body>
</html>
